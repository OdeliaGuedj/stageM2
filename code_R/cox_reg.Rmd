---
title: "R Notebook"
output: html_notebook
editor_options: 
  chunk_output_type: inline
---
 
# 1. Creation des variables time_to_event 

Pour les evt == 1 time_to_event = nbr de jours entre inclusion et evenement
Pour les evt == 0 time_to_event = nbr de jours total d'observation du sujet = nbr de jour entre inclusion et date de dernières nouvelles

```{r}
data$time_to_deces = as.numeric(difftime(data$date_deces, data$datinclu, unit = "days"))
data$time_to_stroke = as.numeric(difftime(data$date_stroke, data$datinclu, unit = "days"))
data$time_to_aomi = as.numeric(difftime(data$date_aomi, data$datinclu, unit = "days"))
data$time_to_chd = as.numeric(difftime(data$date_chd, data$datinclu, unit = "days"))
data$time_to_tdr = as.numeric(difftime(data$date_tdr, data$datinclu, unit = "days"))
```

```{r}
for(evt in var_evt){
  data[,evt] = as.numeric(as.character(data[,evt]))
}
```

```{r}
time_to_evt = c("time_to_stroke", "time_to_aomi", "time_to_tdr", "time_to_chd","time_to_deces")
```

# 2. Fonctions pour modèles de Cox

Les analyses déjà faites avaient la structure suivante
1. Univarié
2. Modèle 1: age + sexe + tabac + activité physique
3. Modèle 2: Modèle 1 + diabète + créatinine
4. Modèle 3: Modèle 2 + bmi
5. Modèle 4: Modèle 3 + mean blood pressure

Mais convenu avec JPE (mais bon vite fait au tel):
1. Univarié
2. Modèle 1: age + sexe + educ + statut marital
3. Modèle 2: Modèle 1 + tabac + bmi + hdl
4. Modèle 3: Modèle 2 + mean blood pressure



## 2.1 Fonction extract_coxReg
Permet de récuperer proporement les resultats d'un modèle de cox (à améliorer si jamais on abesoin de plus d'informations par la suite comme nevents, test de vrais, et pvalue associée...)
Ajouter un argument booléen qui permet de sortir le code latex (Kable) plutot qu'un dataframe
```{r}
extract_coxReg = function(cox_model, round = T,d.round= 2, alpha = 0.05){
  summary = summary(cox_model)
  if (round == T){
    df = data.frame("Names" = rownames(summary$coefficients),
                    "HR" = round(summary$coefficient[,2],d.round),
                    "IC" = paste0("[", round(summary$conf.int[,3],d.round +1), " ; ", round(summary$conf.int[,4],d.round+1), "]"),
                    "p.value" = signif(summary$coefficient[,5],3),
                    "Signif" = ifelse(summary$coefficient[,5] <= 0.05, "*"," "))
   return(df)
  } 
  
  else{
    df = data.frame("Names" = rownames(summary$coefficients),
                    "HR" = summary$coefficient[,2],
                    "ICinf" = summary$conf.int[,3],
                    "ICsup" = summary$conf.int[,4],
                    "p.value" = summary$coefficient[,5])
  df$pv_signif = ifelse(df$p.value <= alpha , 1, 0)
  
  return(df)
  
  }
  
}
```

## 2.2 Fonction cox_univar
Permet de faire des modèles de cox univariés et d'avoir les resultats sous la forme extract_coxReg (donc dataframe).
ça sera utile quand on devra faire toutes les analyses univariées des paramètres d'echotracking (presque 50 paramètres) pour chachun des evts (5) -> 250 models...
```{r}
cox_univar = function(time, var, evt, dt, round = T){
  # Round est util car on utilise la fonction extract_coxReg pour avoir les res sous un joli format et cet arguments existe dans cette fonction (il vaut T par defaut). Donc l'arg round de cox_univar n'est utile que si pour une raison obscure on veut les res dasn un tableau sans arrondis
  time = as.numeric(as.character(dt[,time]))
  evt = as.numeric(as.character(dt[,evt]))
  model = coxph(Surv(time,evt) ~ dt[,var], data = dt)
  res = extract_coxReg(model, round)
  res$p.shonfeld = signif(cox.zph(model)$table[3],3)
  res$Names = var
  res$n = model$n
  res$n.events = model$nevent
  return(list("res_df" = res, "model" = model))
}
```


## 2.3 Fonction plot_pv_HR
Permet d'afficher les HR  de modèles univariés (Autant de paramètres qu'on veut pour 1 evenement particulier) avec un code couleur pour leur significativité.
```{r}
plot_pv_HR = function(extract_coxReg_obj, hj = 0, vj = 0, main = " "){
  # Pour pouvoir utiliser cette fonction sur un obj extract_coxReg il faut que la fonction extract_coxReg aie été utilisée avec l'arument round = F
  ggplot(extract_coxReg_obj, aes(extract_coxReg_obj$p.value, extract_coxReg_obj$HR)) + 
    geom_point(color = dplyr::case_when(extract_coxReg_obj$pv_signif == 1 ~ "green", 
                                      extract_coxReg_obj$pv_signif == 0 ~ "red")) +
    geom_hline(yintercept = 1) +
    scale_y_continuous(name="HR",limits=c(min(extract_coxReg_obj$HR)-0.1 , max(extract_coxReg_obj$HR)+0.1)) +
    geom_text_repel(aes(label = Names),
                  box.padding   = 0.35, 
                  point.padding = 0.5,
                  segment.color = "grey50",
                  force = 15,
                  segment.size  = 0.5 ,#epaisseur segments
                  size = 3 #taille label
    )+
    xlab("p.values")+
    ggtitle(main)
  
}
```



# 3. Modèles univariés

## 3.1 Paramètres carotidiens prioritaires discutés avec JPE (7)





```{r}
param_carotid = c("logain", "coeffDist","pwvloc", "dploc", "logyoung","imt___m_", "dextdias", "stiffness", "pr_sence_de_plaque_s____l__cho")
```

Exemple pour remplir une list itérativement
```{r}
#ex = cox_univar("time_to_deces", "logain", "deces", data)$res_df
# list_mod_ex = list()
# for(i in 1:5){
#   list_mod_ex[[i]] = ex
#   
# }
# length(list_mod_ex) 
# list_mod_ex[[1]]
# names(list_mod_ex) = rep("test",5)
# list_mod_ex$test
```



```{r}
i = 1
list_univar_pc = list()
for(evt in var_evt){
  time = paste0("time_to_",evt)
  res_univar_pc = data.frame()
  for(var in param_carotid){
    cox = cox_univar(time, var, evt, data)
    res_univar_pc = rbind(res_univar_pc, cox$res_df)
  }
  res_univar_pc$Evt = rep(evt,nrow(res_univar_pc))
  list_univar_pc[[i]] = res_univar_pc
  i = i+1
}
names(list_univar_pc) = var_evt


list_univar_pc[["deces"]]
```


## 3.2 Modèls de Cox univariés pour toutes las variables numériques d'échotracking
```{r}
i = 1
list_univar_et = list()
for(evt in var_evt){
  time = paste0("time_to_",evt)
  res_univar_et = data.frame()
  for(var in colnames(data_echo)){
    cox = cox_univar(time, var, evt, data, round = F)
    res_univar_et = rbind(res_univar_et, cox$res_df)
  }
  res_univar_et$Evt = rep(evt,nrow(res_univar_et))
  list_univar_et[[i]] = res_univar_et
  i = i+1
}
names(list_univar_et) = var_evt

list_univar_et[["deces"]]
```
```{r}
plot_pv_HR(list_univar_et[["stroke"]], main = "Accident Vasculaire Cerebral")
```




















## 3.1 Les modèles des analyses déjà effectuées (uniquement à baseline)

### 3.1.1  Log_young

#### 3.1.1.1 Deces

```{r}
data$deces = as.numeric(as.character(data$deces))
logyoung_deces_univar = coxph(Surv(time_to_deces,deces)~ logyoung, data = data)
logyoung_deces_mod1 = coxph(Surv(time_to_deces,deces)~ logyoung + age0 + sexe + qm16 + qm10, data = data)
logyoung_deces_mod2 = coxph(Surv(time_to_deces,deces)~ logyoung + age0 + sexe + qm16 +  qm10 + diab + bio10, data = data)
logyoung_deces_mod3 = coxph(Surv(time_to_deces,deces)~ logyoung + age0 + sexe + qm16 +  qm10 + diab + bio10 + bmi, data = data)
logyoung_deces_mod4 = coxph(Surv(time_to_deces,deces)~ logyoung + age0 + sexe + qm16 +  qm10 + diab + bio10 + bmi + mbp, data = data)
```
```{r}
summary(logyoung_deces_univar)
summary(logyoung_deces_mod4)
```

### 3.1.2. stroke

```{r}
data$stroke = as.numeric(as.character(data$stroke))
logyoung_stroke_univar = coxph(Surv(time_to_stroke,stroke)~ log_young, data = data)
logyoung_stroke_mod1 = coxph(Surv(time_to_stroke,stroke)~ log_young + age0 + sexe + qm16 + qm10, data = data)
logyoung_stroke_mod2 = coxph(Surv(time_to_stroke,stroke)~ log_young + age0 + sexe + qm16 +  qm10 + diab + bio10, data = data)
logyoung_stroke_mod3 = coxph(Surv(time_to_stroke,stroke)~ log_young + age0 + sexe + qm16 +  qm10 + diab + bio10 + bmi, data = data)
logyoung_stroke_mod4 = coxph(Surv(time_to_stroke,stroke)~ log_young + age0 + sexe + qm16 +  qm10 + diab + bio10 + bmi + mbp, data = data)
```
```{r}
summary(logyoung_stroke_univar)
summary(logyoung_stroke_mod1)
```

### 3.1.3 chd

```{r}
data$chd = as.numeric(as.character(data$chd))
logyoung_chd_univar = coxph(Surv(time_to_chd,chd)~ log_young, data = data)
logyoung_chd_mod1 = coxph(Surv(time_to_chd,chd)~ log_young + age0 + sexe + qm16 + qm10, data = data)
logyoung_chd_mod2 = coxph(Surv(time_to_chd,chd)~ log_young + age0 + sexe + qm16 +  qm10 + diab + bio10, data = data)
logyoung_chd_mod3 = coxph(Surv(time_to_chd,chd)~ log_young + age0 + sexe + qm16 +  qm10 + diab + bio10 + bmi, data = data)
logyoung_chd_mod4 = coxph(Surv(time_to_chd,chd)~ log_young + age0 + sexe + qm16 +  qm10 + diab + bio10 + bmi + mbp, data = data)
```
```{r}
summary(logyoung_chd_univar)
summary(logyoung_chd_mod1)
```

### 3.1.4 aomi
```{r}
data$aomi = as.numeric(as.character(data$aomi))
logyoung_aomi_univar = coxph(Surv(time_to_aomi,aomi)~ log_young, data = data)
logyoung_aomi_mod1 = coxph(Surv(time_to_aomi,aomi)~ log_young + age0 + sexe + qm16 + qm10, data = data)
logyoung_aomi_mod2 = coxph(Surv(time_to_aomi,aomi)~ log_young + age0 + sexe + qm16 +  qm10 + diab + bio10, data = data)
logyoung_aomi_mod3 = coxph(Surv(time_to_aomi,aomi)~ log_young + age0 + sexe + qm16 +  qm10 + diab + bio10 + bmi, data = data)
logyoung_aomi_mod4 = coxph(Surv(time_to_aomi,aomi)~ log_young + age0 + sexe + qm16 +  qm10 + diab + bio10 + bmi + mbp, data = data)
```


### 3.1.5 tdr
```{r}
data$tdr = as.numeric(as.character(data$tdr))
logyoung_tdr_univar = coxph(Surv(time_to_tdr,tdr)~ log_young, data = data)
logyoung_tdr_mod1 = coxph(Surv(time_to_tdr,tdr)~ log_young + age0 + sexe + qm16 + qm10, data = data)
logyoung_tdr_mod2 = coxph(Surv(time_to_tdr,tdr)~ log_young + age0 + sexe + qm16 +  qm10 + diab + bio10, data = data)
logyoung_tdr_mod3 = coxph(Surv(time_to_tdr,tdr)~ log_young + age0 + sexe + qm16 +  qm10 + diab + bio10 + bmi, data = data)
logyoung_tdr_mod4 = coxph(Surv(time_to_tdr,tdr)~ log_young + age0 + sexe + qm16 +  qm10 + diab + bio10 + bmi + mbp, data = data)
```





