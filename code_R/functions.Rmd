---
title: "R Notebook"
output: html_notebook
---


Permet de faire des modeles de cox univariés et d'avoir les resultats sous la forme extract_coxReg (donc dataframe).

```{r}
cox_univar = function(time, var, evt, dt, round = T, d.round = 2, alpha = 0.05, interaction = F, var.inter){
  
  # time : time-to-event
  # evt : variable d'evenement (binaire)
  # var : liste de variables explicatives
  # dt : dateframe contennant toues les var citées plus haut
  # round : variable booléenne d'arondis, F par défaut. Valeur T utile pour les graphes
  # d.round : nb de décimale conservée aprés arrondis, 2 par défaut
  # alpha : risque de première éspèce. 5% par défaut
  # interaction : variable booléenne sur inclusion d'une interraction. FALSE par defaut
  # var.inter : variable d'interraction, uniquement si interraction vaut TRUE
  
  
  # On s'assure que le time-to-event et l'event sont bien numériques
  time = as.numeric(as.character(dt[,time]))
  evt = as.numeric(as.character(dt[,evt]))
  
  # On fit le modèle
  if(interaction == T){
    model = coxph(Surv(time,evt) ~ dt[,var] + dt[,var]*dt[,var.inter], data = dt)}
  else
    model = coxph(Surv(time,evt) ~ dt[,var], data = dt)
  
  summary = summary(model)
  
  #test de shonfeld pour vérifier l'hypothèse de proportionnalité des risques
  test.shonfeld = cox.zph(model)
  
  # Construction du dataframe final arrondi ou non
  if (round == T){
    
    df = data.frame("Name" = var,
                    "HR" = round(summary$coefficient[length(summary$coefficient[,2]),2],d.round),
                    "IC" = paste0("[", round(summary$conf.int[length(summary$conf.int[,3]),3],d.round +1), " ; ", ... = round(summary$conf.int[length(summary$conf.int[,4]),4],d.round+1), "]"),
                    "p.value" = signif(summary$coefficient[length(summary$coefficient[,5]),5],3),
                    "pv_signif" = ifelse(summary$coefficient[length(summary$coefficient[,5]),5] <= alpha, "*"," "),
                    "p.shonfeld" = signif(test.shonfeld$table[dim(test.shonfeld$table)[1],dim(test.shonfeld$table)[2]],d.round+1),
                    "n" = model$n,
                    "n.events" = model$nevent
                    )
    
    
   return(list("res_df"=df, "model" = model))
  } 
  
  else if (round == F){
    
    df = data.frame("Name" = var,
                    "HR" = summary$coefficient[length(summary$coefficient[,2]),2],
                    "ICinf" = summary$conf.int[length(summary$conf.int[,3]),3],
                    "ICsup" = summary$conf.int[length(summary$conf.int[,4]),4],
                    "p.value" = summary$coefficient[length(summary$coefficient[,5]),5],
                    "pv_signif" = ifelse(summary$coefficient[length(summary$coefficient[,5]),5] <= alpha, 1,0),
                    "p.shonfeld" = signif(test.shonfeld$table[dim(test.shonfeld$table)[1],dim(test.shonfeld$table)[2]],d.round+1),
                    "Hyp.Prop.verif" = ifelse(test.shonfeld$table[dim(test.shonfeld$table)[1],dim(test.shonfeld$table)[2]] <= alpha ,0,1),
                    "n" = model$n,
                    "n.events" = model$nevent
                    )
  
    return(df)
  
  }
}
```


Permet d'afficher les HR  de modèles univariés (Autant de paramètres qu'on veut pour 1 evenement particulier) avec un code couleur pour leur significativité.



```{r}
plot_pv_HR  = function(cox_nice_info, hj = 0, vj = 0, main = " "){
  
  # Pour pouvoir utiliser cette fonction il faut que cox_nice_info soit un objet cox_univar ou cox_multivar utilisé avec l'argument round = F
  
  # Extraction des noms des param et
  tmp = c()
  for(var in cox_nice_info$Name)
    {tmp = c(tmp,which(echotracking == var))}
  cox_nice_info$Name_nice = names_echotracking[tmp]
  
  # Colonne pour couleur et legende
   for(i in 1:nrow(cox_nice_info)){
     # hypoyhèse de proportionalité non vérifiée
     if(cox_nice_info[i,"Hyp.Prop.verif"] == 0)
     {cox_nice_info[i,"col"] = "Hyp non verified"}
     # non significatif
     else if ((cox_nice_info[i,"Hyp.Prop.verif"] == 1) & (cox_nice_info[i,"pv_signif"] == 0) )
     {cox_nice_info[i,"col"] = "Non significant"}
     # effet protecteur
     else if ((cox_nice_info[i,"Hyp.Prop.verif"] == 1) & (cox_nice_info[i,"pv_signif"] == 1) & (cox_nice_info[i,"HR"] <= 1))
     {cox_nice_info[i,"col"] = "Protective effect"}
     # effet deletere
     else if((cox_nice_info[i,"Hyp.Prop.verif"] == 1) & (cox_nice_info[i,"pv_signif"] == 1) & (cox_nice_info[i,"HR"] > 1))
     {cox_nice_info[i,"col"] = "Deleterious effect"}
   }
  cox_nice_info$col = as.factor(cox_nice_info$col)
  
  
  ggplot(cox_nice_info,aes(p.value, HR, color = col)) +

  geom_point(size = 3) +

  scale_y_continuous(name="HR",limits=c(min(cox_nice_info$HR)-0.1 , max(cox_nice_info$HR)+0.1)) +
    

  theme_classic() +

  geom_text_repel(aes(label = Name_nice),
                  segment.colour = NA,
                  box.padding   = 0.35,
                  point.padding = 0.5,
                  #segment.color = "black",
                  force = 5,
                  segment.size  = .7 ,#epaisseur segments
                  size = 3 #taille label
                     ) +


  labs(title = main, y = "Hazard Ratio", x = "p value", color = " ")
  
  #return(cox_nice_info[,c("Name","Name_nice")])
  
}
```

Idem que plot_pv_HR mais sans la catégorie de verification de l'hypothèse des risques proportionnelsS.

```{r}
plot_pv_HR2  = function(cox_nice_info, hj = 0, vj = 0, main = " "){
  
  # Pour pouvoir utiliser cette fonction il faut que cox_nice_info soit un objet cox_univar ou cox_multivar utilisé avec l'argument round = F
  
  # Extraction des noms des param et
  tmp = c()
  for(var in cox_nice_info$Name)
  {
    tmp = c(tmp,which(echotracking == var))
    }
   cox_nice_info$Name_nice = names_echotracking[tmp]
  

  # Colonne pour couleur et legende
   for(i in 1:nrow(cox_nice_info)){
     # non significatif
     if ((cox_nice_info[i,"pv_signif"] == 0) )
     {cox_nice_info[i,"col"] = "Non significant"}
     # effet protecteur
     else if ((cox_nice_info[i,"pv_signif"] == 1) & (cox_nice_info[i,"HR"] <= 1))
     {cox_nice_info[i,"col"] = "Protective effect"}
     # effet deletere
     else if((cox_nice_info[i,"pv_signif"] == 1) & (cox_nice_info[i,"HR"] > 1))
     {cox_nice_info[i,"col"] = "Deleterious effect"}
   }
  cox_nice_info$col = as.factor(cox_nice_info$col)


  ggplot(cox_nice_info,aes(p.value, HR, color = col)) +

  geom_point(size = 3) +

  scale_y_continuous(name="HR",limits=c(min(cox_nice_info$HR)-0.1 , max(cox_nice_info$HR)+0.1)) +


  theme_classic() +

  geom_text_repel(aes(label = Name_nice),
                  segment.colour = NA,
                  box.padding   = 0.35,
                  point.padding = 0.5,
                  #segment.color = "black",
                  force = 5,
                  segment.size  = .7 ,#epaisseur segments
                  size = 3 #taille label
                     ) +


  labs(title = main, y = "Hazard Ratio", x = "p value", color = " ")

  #return(cox_nice_info[,c("Name","Name_nice")])
  
}
```

```{r}
plot_pv_HR3  = function(cox_nice_info, hj = 0, vj = 0, main = " ", nice.names = T){
  
  # Pour pouvoir utiliser cette fonction il faut que cox_nice_info soit un objet cox_univar ou cox_multivar utilisé avec l'argument round = F
  
  # Extraction des noms des param et
  
  if(nice.names == T){
    tmp = c()
  for(var in cox_nice_info$Name)
  {
    tmp = c(tmp,which(echotracking == var))
    }
   cox_nice_info$Name_nice = names_echotracking[tmp]
  

  # Colonne pour couleur et legende
   for(i in 1:nrow(cox_nice_info)){
     # non significatif
     if ((cox_nice_info[i,"pv_signif"] == 0) )
     {cox_nice_info[i,"col"] = "Non significant"}
     # effet protecteur
     else if ((cox_nice_info[i,"pv_signif"] == 1) & (cox_nice_info[i,"HR"] <= 1))
     {cox_nice_info[i,"col"] = "Protective effect"}
     # effet deletere
     else if((cox_nice_info[i,"pv_signif"] == 1) & (cox_nice_info[i,"HR"] > 1))
     {cox_nice_info[i,"col"] = "Deleterious effect"}
   }
  cox_nice_info$col = as.factor(cox_nice_info$col)


  ggplot(cox_nice_info,aes(p.value, HR, color = col)) +

  geom_point(size = 3) +

  scale_y_continuous(name="HR",limits=c(min(cox_nice_info$HR)-0.1 , max(cox_nice_info$HR)+0.1)) +


  theme_classic() +
    
     scale_colour_manual(values = c("red", "blue", "green")) +

  geom_text_repel(aes(label = Name_nice),
                  segment.colour = NA,
                  box.padding   = 0.35,
                  point.padding = 0.5,
                  #segment.color = "black",
                  force = 5,
                  segment.size  = .7 ,#epaisseur segments
                  size = 3 #taille label
                     ) +


  labs(title = main, y = "Hazard Ratio", x = "p value", color = " ")
    
  }
  
  else if(nice.names == F){
    

  # Colonne pour couleur et legende
   for(i in 1:nrow(cox_nice_info)){
     # non significatif
     if ((cox_nice_info[i,"pv_signif"] == 0) )
     {cox_nice_info[i,"col"] = "Non significant"}
     # effet protecteur
     else if ((cox_nice_info[i,"pv_signif"] == 1) & (cox_nice_info[i,"HR"] <= 1))
     {cox_nice_info[i,"col"] = "Protective effect"}
     # effet deletere
     else if((cox_nice_info[i,"pv_signif"] == 1) & (cox_nice_info[i,"HR"] > 1))
     {cox_nice_info[i,"col"] = "Deleterious effect"}
   }
  cox_nice_info$col = as.factor(cox_nice_info$col)


  ggplot(cox_nice_info,aes(p.value, HR, color = col)) +

  geom_point(size = 3) +

  scale_y_continuous(name="HR",limits=c(min(cox_nice_info$HR)-0.1 , max(cox_nice_info$HR)+0.1)) +


  theme_classic() +
  
    scale_colour_manual(values = c("red", "blue", "green")) +

  geom_text_repel(aes(label = Name),
                  segment.colour = NA,
                  box.padding   = 0.35,
                  point.padding = 0.5,
                  #segment.color = "black",
                  force = 5,
                  segment.size  = .7 ,#epaisseur segments
                  size = 3 #taille label
                     ) +


  labs(title = main, y = "Hazard Ratio", x = "p value", color = " ")
  }
  
  


  
}
```
Permet de fiter des régressions de cox multivariées et de récupérer les info du dernier coefficients qui correspond au paramètre d'échotracking que l'on étudie.

```{r}
cox_multivar = function(formula, list_param, dt, round = T, d.round = 2){
  
  df_res = data.frame()
  
    for(param in list_param){
     
      f = update(formula, as.formula( paste0(".~.+",param) ) )
      
      cox = coxph(f, data)
      summary = summary(cox)
      test.shonfeld = cox.zph(cox)

      # Pour pouvoir acceder a dernier élément du tableau qui correspond au paramètre d'échotracking qu'on rajoute à la fin de chaque formula
      
      r = nrow(summary$coefficients)

      if(round == T){
          df_tmp = data.frame("Name" = rownames(summary$coefficients)[r],
                    "HR" = round(summary$coefficient[r,2],d.round),
                    "IC" = paste0("[", round(summary$conf.int[r,3],d.round), " ; ",round(summary$conf.int[r,4],d.round), "]"),
                    "p.value" = signif(summary$coefficient[r,5],d.round+3),
                    "Signif" = ifelse(summary$coefficient[r,5] <= 0.05, "*"," "),
                    "p.shonfeld" = signif(test.shonfeld$table[dim(test.shonfeld$table)[1],3],d.round+1),
                    "prop.hyp" = ifelse(test.shonfeld$table[dim(test.shonfeld$table)[1],3] < 0.05,"X"," "))

      }


      else if(round == F){
        df_tmp = data.frame("Name" = rownames(summary$coefficients)[r],
                    "HR" = summary$coefficient[r,2],
                    "ICinf" = summary$conf.int[r,3],
                    "ICsup" = summary$conf.int[r,4],
                    "p.value" = signif(summary$coefficient[r,5],d.round+3),
                    "p.shonfeld" = signif(test.shonfeld$table[dim(test.shonfeld$table)[1],3],d.round+1),
                    "Hyp.Prop.verif" = ifelse(test.shonfeld$table[dim(test.shonfeld$table)[1],3] <= 0.05 ,0,1))
        df_tmp$pv_signif = ifelse(df_tmp$p.value <= 0.05 , 1, 0)

       }

      df_res = rbind(df_res,df_tmp)
       }
   return(df_res)
}
```

  Generer une châine de nom de variables séparés par un +.
```{r}
generate_str_var = function(list_var){
  str = NULL
  for(var in list_var){
    tmp = paste("+",var)
    str = paste0(str,tmp)
  }
  str = substr(str,2,nchar(str))
  return(str)
}
```


Idem à cox_multivar sans le test de schonfeld
```{r}
cox_multivar2 = function(formula, list_param, dt, round = T, d.round = 2){
  
  df_res = data.frame()
  
    for(param in list_param){
      
      f = update(formula, as.formula( paste0(".~.+",param) ) )
      
      cox = coxph(f, data)
      summary = summary(cox)

      # Pour pouvoir acceder a dernier élément du tableau qui correspond au paramètre d'échotracking qu'on rajoute à la fin de chaque formula
      
      r = nrow(summary$coefficients)

      if(round == T){
          df_tmp = data.frame("Name" = rownames(summary$coefficients)[r],
                    "HR" = round(summary$coefficient[r,2],d.round),
                    "IC" = paste0("[", round(summary$conf.int[r,3],d.round), " ; ",round(summary$conf.int[r,4],d.round), "]"),
                    "p.value" = signif(summary$coefficient[r,5],d.round+3),
                    "Signif" = ifelse(summary$coefficient[r,5] <= 0.05, "*"," "))

      }


      else if(round == F){
        df_tmp = data.frame("Name" = rownames(summary$coefficients)[r],
                    "HR" = summary$coefficient[r,2],
                    "ICinf" = summary$conf.int[r,3],
                    "ICsup" = summary$conf.int[r,4],
                    "p.value" = signif(summary$coefficient[r,5],d.round+3))
        df_tmp$pv_signif = ifelse(df_tmp$p.value <= 0.05 , 1, 0)

       }

      df_res = rbind(df_res,df_tmp)
       }
   return(df_res)
}
```
```{r}
generate_str_var = function(list_var){
  str = NULL
  for(var in list_var){
    tmp = paste("+",var)
    str = paste0(str,tmp)
  }
  str = substr(str,2,nchar(str))
  return(str)
}
```


Vérification de la loglinéarité de cox univariés avec la méthode du livre de biostat



```{r}
verifHyp_loglin_coxUnivar = function(var_verif, time, evt, dt, method = "center", nb.class = 4 ){
  #var_verif : (string) variable dont on veut prouver la log linéarité
  #time : (string) le time_to_evt
  #evt : (string) l'évenement
  #dt : (data.frame) le data frame contennant au moins var_verif, time et evt
  #method : (string) à choisir dans "center"(defaut), "mean", "median"
  #nb.class : (integer) nombre de classe à construire à partir de var_verif
  
  
  dt[,time] = as.numeric(dt[,time])
  dt[,evt] = as.numeric(dt[,evt])

  if(!(method %in% c("center", "mean", "median"))){return("method should be one of center, mean or median")}
  
  nb.class = round(nb.class,0)

  dt[,"var_verif_cat"] =lsr::quantileCut(dt[,var_verif],nb.class)
  
  
  res = data.frame("Levels"=rep(NA,nb.class),
                   "N"=rep(NA,nb.class),
                   "tmp"=rep(NA,nb.class),
                   "d"=rep(NA,nb.class),       "HR_computed"=rep(NA,nb.class),
            "HR_fitted"=rep(NA,nb.class),
                   "IC_fitted"=rep(NA,nb.class),
                   "verif" = rep(NA,nb.class))
  
  res$Levels = levels(dt$var_verif_cat)
  res$N = table(dt$var_verif_cat)
  
   if(method == "mean"){
      res$tmp=round(with(dt,tapply(dt[,var_verif],as.factor(dt[,"var_verif_cat"]),mean)),3)
    }
   
    else if(method == "center"){
      res$tmp= round(with(dt,tapply(dt[,var_verif],as.factor(dt[,"var_verif_cat"]),min)) +
        (with(dt,tapply(dt[,var_verif],as.factor(dt[,"var_verif_cat"]),max)) - with(dt,tapply(dt[,var_verif],as.factor(dt[,"var_verif_cat"]),min)))
        /2,0)
    }
   
    else if(method == "median"){
      res$tmp=round(with(dt,tapply(dt[,var_verif],as.factor(dt[,"var_verif_cat"]),median)),3)
    }
  
  res$d = res$tmp - res$tmp[1]
  res$d[1] = 1
  
  cox_cont = summary(coxph(Surv(dt[,time],dt[,evt]) ~ dt[,var_verif], data = dt))
  coef = cox_cont$coefficients[1,1]
  
  res$HR_computed = round(exp(res$d*coef),2)
  res$HR_computed[1] = 1
  
  cox_cat = summary(coxph(Surv(dt[,time],dt[,evt]) ~ var_verif_cat, data = dt))
  
  res$HR_fitted = round(c(1,cox_cat$coefficients[,2]),2)
  
  res$IC_fitted = c("ref.",paste("[",round(cox_cat$conf.int[,3],2),";",round(cox_cat$conf.int[,4],2),"]"))
  
  res$verif[1] = "ref."
  res$verif[2:nb.class] = ifelse((res$HR_computed[2:nb.class]>=cox_cat$conf.int[,3]) & (res$HR_computed[2:nb.class]<=cox_cat$conf.int[,4]) ,"*"," ")
  
  res$HR_computed = as.character(res$HR_computed)
  res$HR_computed[1] = "ref."
  res$HR_fitted = as.character(res$HR_fitted)
  res$HR_fitted[1] = "ref."
  res$N = as.character(res$N)

  return(res[,c("Levels","N","verif","HR_computed","HR_fitted","IC_fitted")])
  }

```

Retirer les outliers methode des quantiles
```{r}
cut_outlier_quantile = function(var,dt,pinf = 0.01){
  #dt: (data.frame) dataframe contennant au moins var
  #var: (string) variable dont on veut retirer les outliers
  #pinf: proportion de valeurs à retirer (borne inf)
  
  psup = 1-pinf
  binf = quantile(dt[,var],pinf, na.rm = T)
  bsup = quantile(dt[,var],psup, na.rm = T)
  out_idx = which(dt[,var] < binf | dt[,var] > bsup)
  var_new = dt[-out_idx,var]
  
  return(list("out_idx" = out_idx, "var_new" = var_new))
}
```
Stocker la legende d'un graphe
```{r}
get_legend =function(myggplot){
  tmp = ggplot_gtable(ggplot_build(myggplot))
  leg = which(sapply(tmp$grobs, function(x) x$name) == "guide-box")
  legend <- tmp$grobs[[leg]]
  return(legend)
}
```

Modèles de cox multivariés avec plusieurs paramètres d'echotracking

```{r}
cox_multivar_multi_param = function(evt, list_param, list_var_ajust, dt, round = T, d.round = 2){
  
  time = paste0("time_to_",evt)
  evt = as.numeric(as.character(data2[,evt]))
  time = as.numeric(as.character(data2[,time]))
  param = generate_str_var(list_param)
  var_ajust = generate_str_var(list_var_ajust)
  f = formula(paste("Surv(time, evt)~", generate_str_var(list_param),"+" ,generate_str_var(list_var_ajust)))
  
  cox = coxph(f,dt)
  summary = summary(cox)
  test.shonfeld = cox.zph(cox)
  
  df_res = data.frame()

    
  r = sum(sapply(dt[,list_param], is.numeric))
  for(p in list_param){if(is.factor(dt[,p])){r = r + length(levels(dt[,p])) - 1 }}

      if(round == T){
          df_tmp = data.frame("Name" = rownames(summary$coefficients)[1:r],
                    "HR" = round(summary$coefficient[1:r,2],d.round),
                    "IC" = paste0("[", round(summary$conf.int[1:r,3],d.round), " ; ",round(summary$conf.int[r,4],d.round), "]"),
                    "p.value" = signif(summary$coefficient[1:r,5],d.round+3),
                    "Signif" = ifelse(summary$coefficient[1:r,5] <= 0.05, "*"," "),
                    "p.shonfeld" = signif(test.shonfeld$table[1:r,3],d.round+1),
                    
                    "prop.hyp" = ifelse(test.shonfeld$table[1:r,3] < 0.05,"X"," ")
                    )

      }
       else if(round == F){
         df_tmp = data.frame("Name" = rownames(summary$coefficients)[1:r],
                     "HR" = summary$coefficient[1:r,2],
                     "ICinf" = summary$conf.int[1:r,3],
                     "ICsup" = summary$conf.int[1:r,4],
                     "p.value" = signif(summary$coefficient[1:r,5],d.round+3),
                     "p.shonfeld" = signif(test.shonfeld$table[1:r,3],d.round+1),
                     "Hyp.Prop.verif" = ifelse(test.shonfeld$table[1:r,3] <= 0.05 ,0,1))
         df_tmp$pv_signif = ifelse(df_tmp$p.value <= 0.05 , 1, 0)
       
       
       
       df_res = rbind(df_res,df_tmp)
       }


  return(df_res)
}
```
Permet de virer les sujets (identifiés par id, var devant être présente dans la base dt) ayant au moins une NA dans au moins une des variables de list_var.


```{r}
subset_SubjectsNA = function(dt, list_var,id){
  na_idx = c()
  for(v in list_var){
    tmp = which(is.na(dt[,v]))
    na_idx = c(na_idx,tmp)
  }
  if(sum(duplicated(na_idx)) != 0){na_idx = na_idx[-which(duplicated(na_idx))]}
  #print(length(na_idx))
  na_id = dt[na_idx,id]
  return(list("data_no_na" = dt[-na_id,], "na_id" = na_id))
    }
```
